import os
import glob
import stat
import shutil
import tarfile
import argparse

from sinol_make import util
from sinol_make.helpers import package_util, parsers, paths
from sinol_make.interfaces.BaseCommand import BaseCommand
from sinol_make.tests.input import InputTest
from sinol_make.tests.output import OutputTest


class Command(BaseCommand):
    """
    Class for "export" command.
    """

    def get_name(self):
        return "export"

    def configure_subparser(self, subparser: argparse.ArgumentParser):
        parser = subparser.add_parser(
            self.get_name(),
            help='Create archive for oioioi upload',
            description='Creates archive in the current directory ready to upload to sio2 or szkopul.')
        parsers.add_compilation_arguments(parser)

    def get_generated_tests(self):
        """
        Returns list of generated tests.
        Executes ingen to check what tests are generated.
        """
        if not self.ingen_exists():
            return []

        working_dir = paths.get_cache_path('export', 'tests')
        if os.path.exists(working_dir):
            shutil.rmtree(working_dir)
        os.makedirs(working_dir)

        ingen = self.get_ingen()
        ingen.compile()
        if not ingen.run(working_dir):
            util.exit_with_error('Failed to run ingen.')

        tests = InputTest.get_all(self.task_id, working_dir)
        return [test.test_id for test in tests]

    def copy_package_required_files(self, target_dir: str):
        """
        Copies package files and directories from
        current directory to target directory.
        :param target_dir: Directory to copy files to.
        """
        if self.ingen_exists():
            ingen = self.get_ingen()
            if ingen.is_shell_ingen():
                st = os.stat(ingen.file_path)
                os.chmod(ingen.file_path, st.st_mode | stat.S_IEXEC)

        files = ['config.yml', 'makefile.in', 'Makefile.in',
                 'prog', 'doc', 'attachments', 'dlazaw']
        for file in files:
            file_path = os.path.join(os.getcwd(), file)
            if os.path.exists(file_path):
                if os.path.isdir(file_path):
                    shutil.copytree(file_path, os.path.join(target_dir, file))
                else:
                    shutil.copy(file_path, target_dir)

        print('Copying example tests...')
        for ext in ['in', 'out']:
            os.mkdir(os.path.join(target_dir, ext))
            for test in glob.glob(os.path.join(os.getcwd(), ext, f'{self.task_id}0*.{ext}')):
                shutil.copy(test, os.path.join(target_dir, ext))

        print('Generating tests...')
        generated_tests = self.get_generated_tests()
        tests_to_copy = []
        all_tests = InputTest.get_all(self.task_id) + \
            OutputTest.get_all(self.task_id)
        for test in all_tests:
            if test.test_id not in generated_tests:
                tests_to_copy.append(test)

        if len(tests_to_copy) > 0:
            print(util.warning(f'Found {len(tests_to_copy)} tests that are not generated by ingen.'))
            for test in tests_to_copy:
                print(util.warning(f'Coping {test.basename}...'))
                shutil.copy(test.file_path, os.path.join(target_dir, test.get_type()))

    def clear_files(self, target_dir: str):
        """
        Clears unnecessary files from target directory.
        :param target_dir: Directory to clear files from.
        """
        files_to_remove = ['doc/*~', 'doc/*.aux', 'doc/*.log', 'doc/*.dvi', 'doc/*.err', 'doc/*.inf']
        for pattern in files_to_remove:
            for f in glob.glob(os.path.join(target_dir, pattern)):
                os.remove(f)

    def create_makefile_in(self, target_dir: str, config: dict):
        """
        Creates required `makefile.in` file.
        :param target_dir: Directory to create files in.
        :param config: Config dictionary.
        """
        with open(os.path.join(target_dir, 'makefile.in'), 'w') as f:
            cxx_flags = '-std=c++20'
            c_flags = '-std=c17'
            def format_multiple_arguments(obj):
                if isinstance(obj, str):
                    return obj
                return ' '.join(obj)

            if 'extra_compilation_args' in config:
                if 'cpp' in config['extra_compilation_args']:
                    cxx_flags += ' ' + format_multiple_arguments(config['extra_compilation_args']['cpp'])
                if 'c' in config['extra_compilation_args']:
                    c_flags += ' ' + format_multiple_arguments(config['extra_compilation_args']['c'])

            f.write(f'MODE = wer\n'
                    f'ID = {self.task_id}\n'
                    f'SIG = sinolmake\n'
                    f'\n'
                    f'TIMELIMIT = {config["time_limit"]}\n'
                    f'SLOW_TIMELIMIT = {4 * config["time_limit"]}\n'
                    f'MEMLIMIT = {config["memory_limit"]}\n'
                    f'\n'
                    f'OI_TIME = oiejq\n'
                    f'\n'
                    f'CXXFLAGS += {cxx_flags}\n'
                    f'CFLAGS += {c_flags}\n')

    def compress(self, target_dir):
        """
        Compresses target directory to archive.
        :param target_dir: Target directory path.
        :return: Path to archive.
        """
        archive = os.path.join(os.getcwd(), f'{self.task_id}.tgz')
        with tarfile.open(archive, "w:gz") as tar:
            tar.add(target_dir, arcname=os.path.basename(target_dir))
        return archive

    def run(self, args: argparse.Namespace):
        super().run(args)
        package_util.validate_test_names(self.task_id)

        export_package_path = paths.get_cache_path('export', self.task_id)
        if os.path.exists(export_package_path):
            shutil.rmtree(export_package_path)
        os.makedirs(export_package_path)

        util.change_stack_size_to_unlimited()
        self.copy_package_required_files(export_package_path)
        self.clear_files(export_package_path)
        self.create_makefile_in(export_package_path, self.config)
        archive = self.compress(export_package_path)

        print(util.info(f'Exported to {self.task_id}.tgz'))
